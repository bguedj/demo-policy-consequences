<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Evidences ‚Äì D√©mo sant√© : d√©cisions et cons√©quences</title>
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; background: #0b0c10; color: #e8e8e8; }
    header { padding: 18px 20px; border-bottom: 1px solid #222; background: #0b0c10; position: sticky; top: 0; z-index: 10; }
    header h1 { margin: 0; font-size: 16px; font-weight: 650; letter-spacing: .2px; }
    header p { margin: 6px 0 0; color: #b7b7b7; font-size: 13px; line-height: 1.35; max-width: 1100px; }
    .wrap { display: grid; grid-template-columns: 380px 1fr; gap: 16px; padding: 16px; }
    .card { background: #12131a; border: 1px solid #242633; border-radius: 14px; padding: 14px; box-shadow: 0 12px 30px rgba(0,0,0,.25); }
    .card h2 { margin: 0 0 10px; font-size: 14px; font-weight: 650; }
    .row { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 10px; margin: 10px 0; }
    .row label { font-size: 13px; color: #d6d6d6; }
    .row .val { font-variant-numeric: tabular-nums; color: #b7b7b7; font-size: 13px; }
    input[type="range"] { width: 100%; }
    select, button { width: 100%; padding: 10px 10px; border-radius: 12px; border: 1px solid #2c2f3d; background: #0f1016; color: #e8e8e8; }
    button { cursor: pointer; font-weight: 650; }
    button:hover { border-color: #4a4f66; }
    .hint { margin-top: 12px; padding: 10px 10px; border-radius: 12px; border: 1px solid #2c2f3d; background: #0f1016; color: #cfcfcf; font-size: 13px; line-height: 1.35; }
    .mini { color: #9aa0a6; font-size: 12px; margin-top: 10px; }
    .badge { display:inline-block; padding: 3px 8px; border: 1px solid #2c2f3d; border-radius: 999px; font-size: 12px; color:#cfcfcf; margin-left: 6px; }
    .gridCharts { display: grid; grid-template-columns: 1fr; gap: 16px; }
    .footer { padding: 0 16px 18px; color: #8f95a0; font-size: 12px; line-height: 1.35; }
    .twoCol { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .pill { display:flex; gap: 8px; align-items:center; }
    .pill input { transform: translateY(1px); }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 12px; padding: 2px 6px; border: 1px solid #2c2f3d; border-radius: 8px; background:#0f1016; color:#cfcfcf; }
    ul { margin: 8px 0 0; padding-left: 18px; }
    li { margin: 4px 0; }
  </style>
</head>
<body>
  <header>
    <h1>D√©mo Evidences (sant√©) ‚Äî D√©cisions, incertitude, cons√©quences <span class="badge">outil p√©dagogique</span></h1>
    <p>
      Ce simulateur n‚Äôest pas une ‚Äúpr√©vision‚Äù. Il illustre comment des choix (plus ou moins align√©s avec l‚Äô√©vidence) modifient une trajectoire
      et <span class="badge">d√©placent la distribution des risques</span>. Les bandes montrent un intervalle plausible (10‚Äì90%).
    </p>
  </header>

  <div class="wrap">
    <div class="card">
      <h2>Param√®tres & modes</h2>

      <div class="row">
        <label for="mode">Mode principal</label>
        <div class="val" id="modeVal"></div>
      </div>
      <select id="mode">
        <option value="evidence">Evidence-based</option>
        <option value="opinion">Opinion-based</option>
        <option value="nosci">No science</option>
      </select>

      <div class="hint" style="margin-top:10px;">
        <div><b>Ce que dit la litt√©rature (tr√®s r√©sum√©)</b></div>
        <div id="lit" style="margin-top:6px;"></div>
        <div style="margin-top:10px;"><b>Ce qui est incertain</b></div>
        <div id="unc" style="margin-top:6px;"></div>
      </div>

      <div class="hint" style="margin-top:10px;">
        <div class="pill">
          <input type="checkbox" id="compare" />
          <label for="compare" style="cursor:pointer;">Comparer deux mondes</label>
          <span class="kbd">A/B</span>
        </div>
        <div class="twoCol" style="margin-top:10px;">
          <div>
            <div class="mini">Monde A</div>
            <select id="modeA">
              <option value="evidence" selected>Evidence-based</option>
              <option value="opinion">Opinion-based</option>
              <option value="nosci">No science</option>
            </select>
          </div>
          <div>
            <div class="mini">Monde B</div>
            <select id="modeB">
              <option value="evidence">Evidence-based</option>
              <option value="opinion">Opinion-based</option>
              <option value="nosci" selected>No science</option>
            </select>
          </div>
        </div>
        <div class="mini" style="margin-top:8px;">
          Quand activ√© : on superpose A et B (m√©dianes + bandes).
        </div>
      </div>

      <div class="row" style="margin-top:14px;">
        <label>Vaccination (%)</label>
        <div class="val" id="vaxVal"></div>
      </div>
      <input id="vax" type="range" min="0" max="95" step="1" value="65" />

      <div class="row">
        <label>R√©duction de contacts (%)</label>
        <div class="val" id="distVal"></div>
      </div>
      <input id="dist" type="range" min="0" max="70" step="1" value="25" />

      <div class="row">
        <label>D√©lai de r√©action (jours)</label>
        <div class="val" id="delayVal"></div>
      </div>
      <input id="delay" type="range" min="0" max="28" step="1" value="7" />

      <div class="row">
        <label>Capacit√© hospitali√®re (lits)</label>
        <div class="val" id="capVal"></div>
      </div>
      <input id="cap" type="range" min="200" max="6000" step="50" value="1800" />

      <div class="row">
        <label>S√©v√©rit√© (IFR ‚Ä∞)</label>
        <div class="val" id="ifrVal"></div>
      </div>
      <input id="ifr" type="range" min="0.2" max="6.0" step="0.1" value="1.2" />

      <div class="row">
        <label>Horizon (jours)</label>
        <div class="val" id="daysVal"></div>
      </div>
      <input id="days" type="range" min="60" max="365" step="5" value="180" />

      <div class="row">
        <label>Simulations (Monte-Carlo)</label>
        <div class="val" id="mcVal"></div>
      </div>
      <input id="mc" type="range" min="60" max="600" step="20" value="260" />

      <div class="twoCol" style="margin-top:12px;">
        <button id="roulette">üé≤ Policy roulette</button>
        <button id="run">Simuler</button>
      </div>

      <div class="hint" id="narrative"></div>

      <div class="hint" style="margin-top:10px;">
        <div class="pill">
          <input type="checkbox" id="showAssumptions" />
          <label for="showAssumptions" style="cursor:pointer;">Afficher les hypoth√®ses implicites</label>
        </div>
        <div id="assumptions" style="display:none;"></div>
      </div>

      <div class="mini">
        Tout change automatiquement quand tu touches un r√©glage (debounce ~350ms).
      </div>
    </div>

    <div class="gridCharts">
      <div class="card">
        <h2>Infections actives</h2>
        <div id="chartI" style="height:320px;"></div>
      </div>
      <div class="card">
        <h2>Hospitalisations (et capacit√©)</h2>
        <div id="chartH" style="height:320px;"></div>
      </div>
      <div class="card">
        <h2>D√©c√®s cumul√©s</h2>
        <div id="chartD" style="height:320px;"></div>
      </div>
    </div>
  </div>

  <div class="footer">
    <strong>Note.</strong> Mod√®le jouet (SIR discret + d√©lais) avec param√®tres incertains. L‚Äôobjectif est l‚Äôintuition : rendre visible
    ce qu‚Äôune d√©cision suppose et ce qu‚Äôelle met en risque. On pourra ensuite ajouter des param√®tres ‚Äúsourc√©s‚Äù
    (VE, R0, d√©lais, etc.) et des liens ‚Äî sans alourdir la d√©mo.
  </div>

<script>
  // ========= Utilities =========
  function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
  function quantile(sortedArr, q){
    const n = sortedArr.length;
    if(n === 0) return NaN;
    const pos = (n - 1) * q;
    const base = Math.floor(pos);
    const rest = pos - base;
    if(sortedArr[base + 1] !== undefined){
      return sortedArr[base] + rest * (sortedArr[base + 1] - sortedArr[base]);
    }
    return sortedArr[base];
  }
  function lognormal(median, sigma){
    // median in log-space; sigma controls spread
    const u1 = Math.random() || 1e-9;
    const u2 = Math.random() || 1e-9;
    const z = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2*Math.PI*u2);
    return Math.exp(Math.log(median) + sigma*z);
  }

  const el = (id) => document.getElementById(id);

  // ========= UI handles =========
  const mode = el("mode"), vax = el("vax"), dist = el("dist"), delay = el("delay"),
        cap = el("cap"), ifr = el("ifr"), days = el("days"), mc = el("mc"),
        runBtn = el("run"), rouletteBtn = el("roulette"),
        compare = el("compare"), modeA = el("modeA"), modeB = el("modeB"),
        showAssumptions = el("showAssumptions");

  // ========= Narrative blocks =========
  function modeLabel(key){
    const map = { evidence: "Evidence-based", opinion: "Opinion-based", nosci: "No science" };
    return map[key] || key;
  }

  function updateLitAndUnc(){
    const key = mode.value;
    const lines = {
      evidence: {
        lit: "Les r√©ponses rapides, adaptatives et proportionn√©es tendent √† r√©duire les pics et √† limiter les d√©passements hospitaliers ‚Äî sans √©liminer l‚Äôincertitude.",
        unc: "Efficacit√© r√©elle (vaccin/mesures), adh√©sion, d√©lais, h√©t√©rog√©n√©it√©, et dynamiques de transmission (variants, saisonnalit√©)."
      },
      opinion: {
        lit: "Les d√©cisions guid√©es par des hypoth√®ses optimistes peuvent fonctionner‚Ä¶ mais augmentent souvent la fr√©quence des sc√©narios d√©favorables quand elles tardent √† s‚Äôajuster.",
        unc: "Biais d‚Äôoptimisme, sous-estimation de la variance, r√©action tardive, et effets de second ordre (fatigue, comportements)."
      },
      nosci: {
        lit: "D√©cider sans donn√©es revient √† parier sur un sc√©nario favorable : la moyenne peut sembler acceptable, mais les extr√™mes deviennent plus probables.",
        unc: "Mod√®le mental d√©connect√© des signaux, absence de calibration, r√©action tardive : les ‚Äúqueues‚Äù (sc√©narios rares mais graves) dominent le risque."
      }
    };
    el("lit").textContent = lines[key].lit;
    el("unc").textContent = lines[key].unc;
  }

  function narrativeText(){
    const key = mode.value;
    const v = Number(vax.value), d = Number(dist.value), lag = Number(delay.value);
    const base = `R√©glages : vaccination ${v}%, r√©duction contacts ${d}%, d√©lai ${lag}j.`;
    if(key === "evidence"){
      return `<b>${base}</b> Mode <b>Evidence-based</b> : on suppose une surveillance, une r√©action plus fiable, et une meilleure calibration des risques.`;
    } else if(key === "opinion"){
      return `<b>${base}</b> Mode <b>Opinion-based</b> : hypoth√®ses plus optimistes + ajustements plus lents ‚Üí incertitude plus large et pics plus probables.`;
    }
    return `<b>${base}</b> Mode <b>No science</b> : agir tard (ou pas) revient √† supposer implicitement que le risque est faible. Le risque se d√©place vers les extr√™mes.`;
  }

  function assumptionsList(){
    const key = mode.value;
    const v = Number(vax.value), d = Number(dist.value), lag = Number(delay.value), c = Number(cap.value), ifrVal = Number(ifr.value);
    const items = [];

    // Hypoth√®ses ‚Äúimplicites‚Äù (p√©dagogiques, pas scientifiques)
    items.push(`Les param√®tres choisis sont suppos√©s ‚Äústables‚Äù sur l‚Äôhorizon (‚âà ${days.value} jours), sauf bruit/variabilit√© interne.`);
    items.push(`La vaccination (${v}%) r√©duit √† la fois la transmission (partiellement) et la s√©v√©rit√© (partiellement).`);
    items.push(`La r√©duction de contacts (${d}%) est un proxy d‚Äôadh√©sion aux mesures et de changements de comportement.`);
    items.push(`Le d√©lai (${lag} jours) suppose un temps de d√©tection/validation/d√©cision + mise en ≈ìuvre.`);
    items.push(`La capacit√© hospitali√®re (${c} lits) est fixe et sert d‚Äôindicateur de saturation (ce n‚Äôest pas un ‚Äúseuil dur‚Äù).`);
    items.push(`La s√©v√©rit√© (IFR ‚âà ${ifrVal}‚Ä∞) repr√©sente un ordre de grandeur : elle varie fortement selon √¢ge, comorbidit√©s, et contexte.`);

    if(key === "evidence"){
      items.push(`Sp√©cifique ‚ÄúEvidence-based‚Äù : on suppose une r√©ponse plus fiable et proportionn√©e (moins de variance).`);
    } else if(key === "opinion"){
      items.push(`Sp√©cifique ‚ÄúOpinion-based‚Äù : on suppose un biais d‚Äôoptimisme et une r√©action moins robuste aux signaux faibles.`);
    } else {
      items.push(`Sp√©cifique ‚ÄúNo science‚Äù : on suppose une r√©ponse tardive/instable, augmentant la probabilit√© de sc√©narios extr√™mes.`);
    }

    return `<ul>${items.map(x => `<li>${x}</li>`).join("")}</ul>`;
  }

  function syncLabels(){
    el("modeVal").textContent = modeLabel(mode.value);
    el("vaxVal").textContent = `${vax.value}%`;
    el("distVal").textContent = `${dist.value}%`;
    el("delayVal").textContent = `${delay.value} j`;
    el("capVal").textContent = `${cap.value}`;
    el("ifrVal").textContent = `${Number(ifr.value).toFixed(1)} ‚Ä∞`;
    el("daysVal").textContent = `${days.value} j`;
    el("mcVal").textContent = `${mc.value}`;
    el("narrative").innerHTML = narrativeText();

    updateLitAndUnc();

    if(showAssumptions.checked){
      el("assumptions").style.display = "block";
      el("assumptions").innerHTML = assumptionsList();
    } else {
      el("assumptions").style.display = "none";
      el("assumptions").innerHTML = "";
    }
  }

  // ========= Simulation model =========
  function simulateOnce(params){
    const {
      N, days, vaxRate, contactRed, reactDelay,
      hospCap, ifrPerThousand,
      modeKey
    } = params;

    const gamma = 1/6.0;
    const I0 = 400;
    let S = N - I0;
    let I = I0;
    let R = 0;

    // Uncertainty (toy)
    let R0 = clamp(lognormal(2.6, 0.18), 1.4, 6.0);

    let VEinf = clamp(0.55 + 0.12*(lognormal(1,0.25)-1), 0.15, 0.85);
    let VEsev = clamp(0.78 + 0.10*(lognormal(1,0.20)-1), 0.40, 0.95);

    let adher = clamp((contactRed/100) * clamp(lognormal(1.0, 0.18), 0.3, 1.4), 0.0, 0.8);

    let responseStrength = 0.0;
    let responseNoise = 0.0;

    if(modeKey === "evidence"){
      responseStrength = 0.55;
      responseNoise = 0.10;
    } else if(modeKey === "opinion"){
      responseStrength = 0.30;
      responseNoise = 0.20;
      R0 *= 0.95; // optimism bias
    } else {
      responseStrength = 0.15;
      responseNoise = 0.30;
    }

    const ifr = (ifrPerThousand/1000.0);
    let hospRate = clamp(0.010 * lognormal(1.0, 0.30), 0.003, 0.030);
    hospRate *= (1 - vaxRate * VEsev);

    const deathRate = clamp(ifr * (1 - vaxRate * VEsev), 0.00005, 0.02);

    const hospLag = 8;
    const deathLag = 18;
    const newInfHist = Array(days+1).fill(0);

    const active = Array(days+1).fill(0);
    const hosp = Array(days+1).fill(0);
    const deadCum = Array(days+1).fill(0);

    const beta0 = R0 * gamma;
    let deaths = 0;

    for(let t=0; t<=days; t++){
      let policyFactor = 1.0;

      if(t >= reactDelay){
        const noise = (lognormal(1.0, responseNoise) - 1.0); // multiplicative-ish
        const eff = clamp(adher * clamp(responseStrength + noise, 0.0, 1.0), 0.0, 0.85);
        policyFactor = 1.0 - eff;
      } else {
        const baseline = (modeKey === "evidence") ? 0.05 : (modeKey === "opinion" ? 0.02 : 0.0);
        policyFactor = 1.0 - baseline;
      }

      const drift = 1.0 + 0.10*Math.sin(2*Math.PI*t/120.0) + 0.04*(lognormal(1.0,0.25)-1.0);
      const beta = clamp(beta0 * drift * policyFactor, 0.02, 2.0);

      const effS = S * (1 - vaxRate*VEinf);

      const newInf = clamp(beta * I * effS / N, 0, S);
      newInfHist[t] = newInf;

      const rec = gamma * I;
      S -= newInf;
      I += newInf - rec;
      R += rec;

      active[t] = I;

      if(t - hospLag >= 0){
        hosp[t] = newInfHist[t - hospLag] * hospRate;
      } else hosp[t] = 0;

      if(t - deathLag >= 0){
        deaths += newInfHist[t - deathLag] * deathRate;
      }
      deadCum[t] = deaths;
    }

    return { active, hosp, deadCum, hospCap };
  }

  function summariseEnsemble(paths){
    const T = paths[0].length;
    const q10 = Array(T).fill(0), q50 = Array(T).fill(0), q90 = Array(T).fill(0);
    for(let t=0; t<T; t++){
      const vals = paths.map(p => p[t]).sort((a,b)=>a-b);
      q10[t] = quantile(vals, 0.10);
      q50[t] = quantile(vals, 0.50);
      q90[t] = quantile(vals, 0.90);
    }
    return { q10, q50, q90 };
  }

  function bandTraces(x, stats, namePrefix){
    // returns traces: low (hidden), high (fill), median
    const { q10, q50, q90 } = stats;
    const low = { x, y: q10, type:"scatter", mode:"lines", line:{width:0}, name: `${namePrefix} 10%`, hoverinfo:"skip", showlegend:false };
    const high = { x, y: q90, type:"scatter", mode:"lines", fill:"tonexty", line:{width:0}, name: `${namePrefix} 10‚Äì90%`, hoverinfo:"skip" };
    const med = { x, y: q50, type:"scatter", mode:"lines", line:{width:2}, name: `${namePrefix} m√©diane` };
    return [low, high, med];
  }

  function plot(divId, x, traces, yLabel){
    const layout = {
      paper_bgcolor: "#12131a",
      plot_bgcolor: "#12131a",
      font: { color: "#e8e8e8" },
      margin: { l: 55, r: 20, t: 10, b: 45 },
      xaxis: { title: "Jour", gridcolor: "#232538", zeroline: false },
      yaxis: { title: yLabel, gridcolor: "#232538", zeroline: false },
      showlegend: true,
      legend: { orientation: "h", y: -0.18, x: 0 },
    };
    Plotly.newPlot(divId, traces, layout, {displayModeBar:false, responsive:true});
  }

  // ========= Auto-run (debounce) =========
  let debounceTimer = null;
  function scheduleRun(){
    syncLabels();
    if(debounceTimer) clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => runSimulation(), 350);
  }

  // ========= Roulette presets =========
  const presets = [
    { name:"Hiver tendu", mode:"evidence", vax:55, dist:35, delay:6, cap:1600, ifr:1.4 },
    { name:"Rel√¢chement rapide", mode:"opinion", vax:60, dist:15, delay:14, cap:1800, ifr:1.2 },
    { name:"D√©ni + faible vaccination", mode:"nosci", vax:25, dist:5, delay:20, cap:1500, ifr:1.5 },
    { name:"Bonne couverture vaccinale", mode:"evidence", vax:80, dist:18, delay:5, cap:2000, ifr:0.9 },
    { name:"Variante plus s√©v√®re", mode:"opinion", vax:65, dist:20, delay:10, cap:1800, ifr:2.4 },
  ];

  function applyPreset(p){
    mode.value = p.mode;
    vax.value = p.vax;
    dist.value = p.dist;
    delay.value = p.delay;
    cap.value = p.cap;
    ifr.value = p.ifr;
    // optional: reduce MC for speed on heavy machines? (leave as is)
    el("narrative").innerHTML = `<b>Preset :</b> ${p.name}. ` + narrativeText();
    scheduleRun();
  }

  // ========= Main simulation =========
  async function runOneWorld(modeKey){
    const N = 1_000_000;
    const T = Number(days.value);
    const vaxRate = Number(vax.value)/100;
    const contactRed = Number(dist.value);
    const reactDelay = Number(delay.value);
    const hospCap = Number(cap.value);
    const ifrPerThousand = Number(ifr.value);
    const M = Number(mc.value);

    const activePaths = [];
    const hospPaths = [];
    const deadPaths = [];

    for(let m=0; m<M; m++){
      const out = simulateOnce({ N, days: T, vaxRate, contactRed, reactDelay, hospCap, ifrPerThousand, modeKey });
      activePaths.push(out.active);
      hospPaths.push(out.hosp);
      deadPaths.push(out.deadCum);

      if(m % 40 === 0) await new Promise(r => setTimeout(r, 0));
    }

    return {
      x: Array.from({length: T+1}, (_,i)=>i),
      I: summariseEnsemble(activePaths),
      H: summariseEnsemble(hospPaths),
      D: summariseEnsemble(deadPaths),
      hospCap
    };
  }

  async function runSimulation(){
    syncLabels();

    runBtn.textContent = "Simulation‚Ä¶";
    runBtn.disabled = true;

    try{
      const T = Number(days.value);
      const x = Array.from({length: T+1}, (_,i)=>i);

      const doCompare = compare.checked;

      if(!doCompare){
        const out = await runOneWorld(mode.value);

        const capTrace = { x, y: x.map(_ => out.hospCap), type:"scatter", mode:"lines", line:{dash:"dash", width:2}, name:"Capacit√©" };

        plot("chartI", x, bandTraces(x, out.I, modeLabel(mode.value)), "Personnes");
        plot("chartH", x, [...bandTraces(x, out.H, modeLabel(mode.value)), capTrace], "Patients");
        plot("chartD", x, bandTraces(x, out.D, modeLabel(mode.value)), "Personnes");
      } else {
        // A/B worlds
        const aKey = modeA.value;
        const bKey = modeB.value;

        // run sequentially (simple) ‚Äî could be parallel but keeping it stable
        const outA = await runOneWorld(aKey);
        const outB = await runOneWorld(bKey);

        const capTrace = { x, y: x.map(_ => Number(cap.value)), type:"scatter", mode:"lines", line:{dash:"dash", width:2}, name:"Capacit√©" };

        plot("chartI", x, [
          ...bandTraces(x, outA.I, `A: ${modeLabel(aKey)}`),
          ...bandTraces(x, outB.I, `B: ${modeLabel(bKey)}`)
        ], "Personnes");

        plot("chartH", x, [
          ...bandTraces(x, outA.H, `A: ${modeLabel(aKey)}`),
          ...bandTraces(x, outB.H, `B: ${modeLabel(bKey)}`),
          capTrace
        ], "Patients");

        plot("chartD", x, [
          ...bandTraces(x, outA.D, `A: ${modeLabel(aKey)}`),
          ...bandTraces(x, outB.D, `B: ${modeLabel(bKey)}`)
        ], "Personnes");

        el("narrative").innerHTML =
          `<b>Comparaison activ√©e.</b> On observe comment la distribution des risques se d√©place entre <b>A</b> et <b>B</b> √† param√®tres identiques.`;
      }
    } finally {
      runBtn.textContent = "Simuler";
      runBtn.disabled = false;
    }
  }

  // ========= Wiring =========
  // Auto-run on every change
  [mode, vax, dist, delay, cap, ifr, days, mc, compare, modeA, modeB].forEach(x => {
    x.addEventListener("input", scheduleRun);
    x.addEventListener("change", scheduleRun);
  });

  runBtn.addEventListener("click", runSimulation);

  rouletteBtn.addEventListener("click", () => {
    const p = presets[Math.floor(Math.random() * presets.length)];
    applyPreset(p);
  });

  showAssumptions.addEventListener("change", () => {
    syncLabels();
  });

  // keyboard shortcut: A/B toggles compare
  window.addEventListener("keydown", (e) => {
    if((e.key || "").toLowerCase() === "b" && (e.ctrlKey || e.metaKey)){
      compare.checked = !compare.checked;
      scheduleRun();
      e.preventDefault();
    }
  });

  // Init
  syncLabels();
  runSimulation();
</script>
</body>
</html>